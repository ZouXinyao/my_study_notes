一、Redis的IO模型

1、Redis是单线程

Redis的单线程指的是Redis 的网络 IO 和数据读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

2、为什么单线程的Redis很快

- Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构（Hash表，跳表等）
- Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。

3、多路复用

3.1基础IO模型

简要版Redis处理一个Get请求的过程：



其中，accept() 和 recv()是阻塞的：

- 当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。
- 当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。

但是可以通过设置将以上两个阻塞点设为非阻塞的。

- 当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。
- 当Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。

但是需要有机制继续监听本应阻塞的套接字，等待连接请求或者等待数据，这时就需要多路复用机制。

3.2基于多路复用的高性能 I/O 模型（select/epoll机制）

多路复用可以达到的效果：多路复用允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，





请求到达时，需要通知到Redis，而且还需要区别不同的事件，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。

事件处理过程：

1. Redis 网络框架调用 epoll 机制，让内核监听这些套接字。
2. select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。
3. 这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。Redis 无需一直轮询是否有请求实际发生。
4. Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。
5. 只要进入队列的事件，Redis都会一件一件处理，所以可以及时响应客户端。

综上，多路复用避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。

二、Redis的阻塞点

1、阻塞点初步统计

| 与redis交互的组件 | 操作                 | 潜在的阻塞点                                                 |
| ----------------- | -------------------- | ------------------------------------------------------------ |
| 客户端            | 网络IO               | bigkey打满网卡                                               |
| 客户端            | 请求操作（增删改查） | O(N)复杂度的操作（集合全量查询和聚合操作）<br />bigkey的删除<br />清空数据库 |
| 磁盘              | 磁盘IO               | 实例内存大导致RDB时fork过程阻塞；<br />AOF的everysec/always导致落盘缓慢 |
| 主从节点          | 主从同步             | 全量和增量复制的缓冲区溢出<br />同步时从库清空数据库的阻塞<br />清空后加载RDB（RDB越大，加载越慢） |
| 切片集群          | 切片集群实例交互     | 迁移bigkey时会阻塞当前线程                                   |

2、哪些可以异步执行

- 删除不需要反馈结果，可以异步执行；AOF不会给redis实例反馈结果，可以异步；
- 读需要将结果反馈给客户端，无法异步；从库如果想提供读服务，必须完成RDB文件的加载，所以无法异步；

三、bigkey对性能的影响

1、bigkey是什么

- value很大的String类型
- 元素个数很多的集合类型

2、bigkey的影响

- 查询变慢
- 占用网络带宽增加，网络带宽的限制导致会影响单机中的其他实例
- 删除操作的阻塞（虽然可以异步执行）
- 数据迁移变慢

3、查询到bigkey后如何处理

- Redis4.0以上的版本可以执行异步删除
- Redis4.0以下的版本可以渐进式删除，避免阻塞

四、缓存机制

1、为什么要有缓冲区？

1.1缓冲区的功能：

用一块内存空间来暂时存放命令数据，以免出现因为数据和命令的处理速度慢于发送速度而导致的数据丢失和性能问题。

1.2缓冲区的注意事项：

如果写入数据的速度持续大于读取缓冲区的速度，会导致缓冲区内的数据持续增加，最后超出阈值，出现缓冲区溢出现象。所以需要正确使用缓冲区机制。

1.3缓冲区的主要应用场景

- 客户端与服务端之间，暂存客户端的命令请求数据；暂存服务端返回给客户端的数据结果。
- 主从节点间进行数据同步时，用来暂存主节点接收的写命令和数据。

2、客户端输入和输出缓冲区

目的：为了避免客户端和服务器端的请求发送和处理速度不匹配

使用方法：输入缓冲区会先把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理。当 Redis 主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端

2.1输入缓冲区溢出

如果输入缓冲区溢出了，就会导致客户端连接关闭，业务无法继续进行。

什么操作会导致输入缓冲区溢出？

- 写入了一个bigkey，比如一次性写入一个数据量很多的集合数据。
- 服务端处理请求数据过慢，会导致缓冲区内存持续增加。

怎么避免输入缓冲区溢出？

- 缓冲区调大，但是无法通过参数调整，上限是1G；
- 避免客户端写入 bigkey；
- 避免 Redis 主线程阻塞。

2.2输出缓冲区溢出

什么情况会导致输入缓冲区溢出？

- 服务器端返回 bigkey 的大量结果；
- 执行了 MONITOR 命令；
- 缓冲区大小设置得不合理。

如何避免？

- 避免 bigkey 操作返回大量数据结果；
- MONITOR 命令用于监测 Redis 执行，其输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出。所以MONITOR 命令主要用在调试环境中，不要在线上生产环境中持续使用 MONITOR。
- 设置缓冲区大小的上限阈值；设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值。

3、主从集群中的缓冲区

3.1全量复制时的缓冲区溢出

如果在全量复制时，从节点接收和加载 RDB 较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。复制缓冲区一旦发生溢出，主节点也会直接关闭和从节点进行复制操作的连接，导致全量复制失败。

**如何避免？**

- 控制主节点保存的数据量大小，让全量同步执行得更快些，避免复制缓冲区累积过多命令。
- 设置合理的复制缓冲区大小。（可以根据实际写命令数据的大小和写命令速率进行估计）
- 控制和主节点连接的从节点个数，不要使用大规模的主从集群。因为主节点复制缓冲区的内存是所有从节点的和。

3.2增量复制时的复制积压缓冲区

复制积压缓冲区时环形缓冲区，要避免产生覆盖的情况。如果产生覆盖，会导致主从节点重新开始全量复制。

如何避免？

调节缓冲区大小。

4、redis性能排查思路