# 一、Redis的数据结构

## 1、基本数据类型

#### 1.1 键值对中值的数据类型：

String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）

#### 1.2 底层数据类型：

简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。

#### 1.3 值的数据类型和底层数据类型对应关系：

![img](https://static001.geekbang.org/resource/image/82/01/8219f7yy651e566d47cc9f661b399f01.jpg)

后四种可以称为集合类型，其特点是：一个键对应了一个集合的数据。

## 2、全局哈希表

#### 2.1 键值对中，键怎么找到对应的值：

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。哈希表中的每个元素保存的并不是值本身，而是指向具体值的指针。不管值是 String，还是集合类型，表中的元素都是指向它们的指针。

这个保存了所有键值对的表称为全局哈希表，通过键可以O(1) 的时间复杂度来快速查找到值，但是哈希表的冲突问题和 rehash 可能带来的操作阻塞。

#### 2.2 哈希冲突

当不同的key通过hash函数计算得到的哈希表索引位置相同就会产生哈希冲突，所以一般同一个位置的多个元素用一个链表来存。

![img](https://static001.geekbang.org/resource/image/8a/28/8ac4cc6cf94968a502161f85d072e428.jpg)

如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。

所以当哈希冲突过多时，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。

## 3、rehash

#### 3.1 rehash过程

Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。当哈希冲突过多时，Redis 开始执行 rehash：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

出现的问题：第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞

#### 3.2 渐进式rehash：

​		在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。

## 4、集合的操作效率

值是string类型时，元素value指针指向的就是当前值。但是集合中，value指针指向的是1个集合，所以在进行增删改查时，需要先找到哈希表中的位置，在再value指向的集合中进行查找。

#### 4.1 压缩列表

压缩列表类似于一个数组，数组中的每一个元素都对应保存一个数据。

压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

![img](https://static001.geekbang.org/resource/image/95/a0/9587e483f6ea82f560ff10484aaca4a0.jpg)

查找第一个和最后一个元素很容易O(1)，但查中间的需要逐个查找O(n)

4.2 跳表

跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位

![img](https://static001.geekbang.org/resource/image/1e/b4/1eca7135d38de2yy16681c2bbc4f3fb4.jpg)

## 5、操作的复杂度

#### 5.1 单元素操作

每一种集合类型对单个数据实现的增删改查操作，复杂度就是由单个元素操作复杂度和元素个数决定的。

#### 5.2 范围操作

集合类型中的遍历操作，可以返回集合中的所有数据，复杂度一般是 O(N)

#### 5.3 统计操作

集合类型对集合中所有元素个数的记录，复杂度只有 O(1)，因为保存数据时会记录元素个数。

#### 5.4 一些特殊的情况，

压缩列表和链表都会记录表头和表尾的偏移量，可以根据现有的信息降低一些操作的复杂度。

## 6、保存数据时的内存计算

#### 6.1 string类型和集合类型的对比：

- string类型适合1个key对1个value；集合类型适合1对多
- string类型保存的元数据多（1个value就需要1组元数据）；集合类型较少（1个集合中的数据用1组元数据）。

所以String 类型并不是适用于所有场合的1个key对1个value，因为它保存数据时所消耗的内存空间较多（需要保存一些元数据）。

#### 6.2 string类型，1个value需要存耗多少内存

![image-20210327020219912](C:\Users\ZXY\AppData\Roaming\Typora\typora-user-images\image-20210327020219912.png)

- 1个entry需要存3个指针24字节，但会分配32字节的内存。key指针和value指针分别指向key值和value值。各自都是1个RedisObject。
- 每个RedisObject都有8字节存元数据，1个指针指向真正存数据的SDS。
- 每个SDS还有4字节len存buf 的已用长度，4字节alloc存buf 的实际分配长度。buf存数据，自动在最后加一个"\0"。

**buf的三种情况：**

- 当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了；
- 字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片（embstr 编码方式）
- 字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。（raw 编码模式）

综上所述，如果值存的是long类型整数，需要消耗32+16+16=64字节内存。

#### 6.3 节省内存的压缩列表的占用内存计算

![img](https://static001.geekbang.org/resource/image/f6/9f/f6d4df5f7d6e80de29e2c6446b02429f.jpg)

- prev_len，表示前一个 entry 的长度。1 字节或 5 字节。当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。
- len：表示自身长度，4 字节；
- encoding：表示编码方式，1 字节；
- content：保存实际数据。

如果内个entry还是保存1个long整型（8个字节）的数据。1个entry是1+4+1+8=14个字节，分配16个。n个数据只需要n×16+一些属性数据；而string类型需要64×n的内存。

#### 6.4 集合类型什么时候使用hash表，什么时候使用压缩数组

Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。一旦转为哈希表就不会转回来。

## 7、实战题目

#### 7.1 云计算平台存储系统软件需要保存亿级的ID对，该使⽤什么样的数据类型？（⼀亿个ID该⽤什么类型保存？）

**分析：**

- 元数据形式为基本的key-value，和String类型匹配，并且String简单易⽤；
- 集合类型针对key:{value1, value2, …, valueN}类型的数据。

**方案一：用string存**

- 内存开销⼤；结构化数据需要进⾏序列化和反序列化。

方案二：用哈希类型存

- 将ID值进⾏拆分，⼀部分作为Hash集合中的key，剩余部分作为Hash集合中的value；
  例如：100001003 -> 100001作为Hash集合的key，003作为Hash集合的value。
- 节省内存消耗。

# 二、高可用相关

Redis 的**持久化**主要有两大机制，即 **AOF**（Append Only File）日志和 **RDB** 快照。

## 1、AOF

**AOF**——写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。

#### 1.1AOF和MySQL的redo log有什么区别：

- redo log记录的是修改后的数据；
- AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的

#### 1.2 AOF的注意点

- AOF先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。
- 不会阻塞当前的写操作；如果在把日志文件写入磁盘时，磁盘写压力大，可能阻塞下一个操作
- 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。

#### 1.3三种写回策略

AOF 配置项 appendfsync 的三个可选值：

- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
  ——可以做到基本不丢数据，但是每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
  ——虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。
- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。
  ——落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；

![img](https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg)

#### 1.4 AOF文件过大

AOF 是以文件的形式在记录接收到的所有写命令。随着接收的写命令越来越多，AOF 文件会越来越大。AOF 文件过大会带来性能问题：

1. 文件系统本身对文件大小有限制，无法保存过大的文件；
2. 如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
3. 如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。

AOF 重写机制可以解决这个问题

#### 1.5 重写机制

在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。

重写过程是由后台子进程 bgrewriteaof 来完成的，不会阻塞主线程。

![img](https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg)

fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。

## 2、RDB（Redis DataBase）

#### 2.1快速恢复的方法

AOF——需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。

**用RDB的方式：**

RDB——把某一时刻的状态以文件的形式写到磁盘上，也就是快照。即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。

#### 2.2执行RDB时是否阻塞当前线程

执行的是全量快照，一次性记录了所有的数据，但是会花费很多时间，数据越多，耗时越长。

2种命令生成RDB：

save：在主线程中执行，会导致阻塞；

bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

#### 2.3执行RDB时是否可以修改数据

因为执行RDB耗时很长，但是执行RDB时阻塞学操作不可接受，所以Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

![img](https://static001.geekbang.org/resource/image/4d/cc/4dc5fb99a1c94f70957cce1ffef419cc.jpg)

- 读操作——主线程和 bgsave 子进程相互不影响
- 写操作——主线程要修改一块数据，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，主线程仍然可以直接修改原来的数据。

#### 2.4是否可以连续执行RDB

频繁执行全量快照的问题：

- 一个没完成了，就开始了另一个，多个快照竞争磁盘带宽。
- fork本身会阻塞主线程，主线程的内存越大，阻塞时间越长，频繁fork，阻塞主线程。

增量快照：

增量快照就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录。但是记录修改的数据会带来额外的空间用来存元数据，而且一般引入的额外开销都比较大。

#### 2.5混合使用 AOF 日志和内存快照

内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

优势：

- 快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。
- AOF 日志也只用记录两次快照间的操作，不需要记录所有操作了，AOF的文件也不会过大，就可以避免重写的开销

#### 2.6 AOF和RDB的选择：

- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
- 如果允许分钟级别的数据丢失，可以只使用 RDB；
- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。

## 3、redis的高可用是什么？





## 4、数据高可用——数据备份时内存增加





## 5、数据高可用——RDB对过期数据的梳理





## 6、实例高可用——主从复制





## 7、实例高可用——哨兵机制





## 8、高可用相关的实际问题





|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |





































