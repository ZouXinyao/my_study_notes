Redis 的**持久化**主要有两大机制，即 **AOF**（Append Only File）日志和 **RDB** 快照。

## 1、AOF

**AOF**——写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。

#### 1.1AOF和MySQL的redo log有什么区别：

- redo log记录的是修改后的数据；
- AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的

#### 1.2 AOF的注意点

- AOF先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。
- 不会阻塞当前的写操作；如果在把日志文件写入磁盘时，磁盘写压力大，可能阻塞下一个操作
- 如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。

#### 1.3三种写回策略

AOF 配置项 appendfsync 的三个可选值：

- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
  ——可以做到基本不丢数据，但是每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；
- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
  ——虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。
- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。
  ——落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；

![img](https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg)

#### 1.4 AOF文件过大

AOF 是以文件的形式在记录接收到的所有写命令。随着接收的写命令越来越多，AOF 文件会越来越大。AOF 文件过大会带来性能问题：

1. 文件系统本身对文件大小有限制，无法保存过大的文件；
2. 如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
3. 如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。

AOF 重写机制可以解决这个问题

#### 1.5 重写机制

在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。

重写过程是由后台子进程 bgrewriteaof 来完成的，不会阻塞主线程。

![img](https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg)

fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。

## 2、RDB（Redis DataBase）

#### 2.1快速恢复的方法

AOF——需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。

**用RDB的方式：**

RDB——把某一时刻的状态以文件的形式写到磁盘上，也就是快照。即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。

#### 2.2执行RDB时是否阻塞当前线程

执行的是全量快照，一次性记录了所有的数据，但是会花费很多时间，数据越多，耗时越长。

2种命令生成RDB：

save：在主线程中执行，会导致阻塞；

bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

#### 2.3执行RDB时是否可以修改数据

因为执行RDB耗时很长，但是执行RDB时阻塞学操作不可接受，所以Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。

![img](https://static001.geekbang.org/resource/image/4d/cc/4dc5fb99a1c94f70957cce1ffef419cc.jpg)

- 读操作——主线程和 bgsave 子进程相互不影响
- 写操作——主线程要修改一块数据，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，主线程仍然可以直接修改原来的数据。

#### 2.4是否可以连续执行RDB

频繁执行全量快照的问题：

- 一个没完成了，就开始了另一个，多个快照竞争磁盘带宽。
- fork本身会阻塞主线程，主线程的内存越大，阻塞时间越长，频繁fork，阻塞主线程。

增量快照：

增量快照就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录。但是记录修改的数据会带来额外的空间用来存元数据，而且一般引入的额外开销都比较大。

#### 2.5混合使用 AOF 日志和内存快照

内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

优势：

- 快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。
- AOF 日志也只用记录两次快照间的操作，不需要记录所有操作了，AOF的文件也不会过大，就可以避免重写的开销

#### 2.6 AOF和RDB的选择：

- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；
- 如果允许分钟级别的数据丢失，可以只使用 RDB；
- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。

## **3、redis的高可用是什么？**

### **3.1数据高可用：实例异常退出时，数据不丢失。**

- redis中可以实现持久化保存数据的机制：RDB、AOF；这两种机制已经保证了redis的数据高可用。
- 多少数据可以实现持久化，需要对可靠性和性能进行取舍。
- 数据高可用保证的是数据不丢失，不会保证数据时刻可用。

### **3.2实例高可用：⼀个实例异常退出时，还有其他实例能提供服务**

实现的方式：主从集群，相关知识包括：主从复制、哨兵机制、故障切换。

需要注意的问题：主从数据的一致性；故障切换失败问题。

## **4、数据高可用——数据备份时内存增加**

使用RDB进行数据可靠性保证时，内存会增加，可能出现卡顿的原因？

- RDB使⽤fork机制创建内存快照；fork的执⾏时间和实例内存⼤⼩有关，所以会有卡顿。
- 创建子进程进行页表复制一定会增加内存，而且如果在复制过程中出现新写操作，还会将新写的原数据重新复制出来一份，也会增加内存。

## **5、数据高可用——RDB对过期数据的梳理**

场景：⼀个Redis实例在2021-03-05 13:18:00，收到如下请求：

```text
set key1 value1
set key2 value2
set key3 value3
expire key1 60
expire key2 300
expire key3 900
```

如果在13:20:00时创建RDB，13:21:00完成RDB快照⽣成，在13:25:00使⽤该RDB恢复⼀个实例，13:26:00恢复完成，恢复后的实例中key1，key2和key3是否都存在？

- key1，在创建RDB时就已经过期，所以key1不存在；
- key2，在使⽤该RDB恢复实例时，key2过期，也不会对key2进行恢复，所以key2不存在；
- key3：恢复实例时也没过期，所以存在。

## **6、实例高可用——主从复制**

主从库之间采用的是读写分离的方式。

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

这样做的好处是所有数据的修改只会在主库上进行，不用协调多个实例。主库有了最新的数据后，会同步给从库，这样，主从库的数据就是一致的。

### **4.1过程：**

1. 建立连接（从->主请求建立连接，主->从反馈主的runID和复制进度）
2. 主库将同步数据发送给从库（发送RDB文件）
3. 复制完成后，将复制阶段新写的数据发送给从库。（发送replication buffer）

### **4.2级联模式**

主从复制中，主库可能存在的阻塞操作：生成RDB和传输RDB

**级联方式**——为了避免多个从库都是从主库进行复制，造成阻塞，redis使用的是主从级联方式分担主库压力。“主-从-从”的级联方式将主库的全量复制的压力分散到从库上。

**长连接**——一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播，可以避免频繁建立连接的开销。

### **4.3主从之间网络断链**

增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库。

一个关键技术：复制积压缓冲区（repl_backlog_buffer）

### **4.4复制积压缓冲区**

当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。

repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。

断连后的同步过程：

1. 刚开始，主从库的读写位置是在一起的；
2. 主库不断接收新的写操作，主库写偏移（master_repl_offset）会不断增加；
3. 当从库复制完写操作后，从库在缓冲区的读偏移（slave_repl_offset）也会逐渐增加；
4. 正常情况下，两个偏移基本相等。断连时，从库的读偏移不动了， 主库的写偏移会继续增加；
5. 当主从断连恢复后，从库会把自己的读偏移发给主库，主库会判断主库的写偏移和从库的读偏移之差，主库只把这两个偏移之间的命令同步到从库上就行。

复制积压缓冲区是环形缓冲区，如果主库的写比从库的读快，会将还没来得及读的操作覆盖，导致主从数据不一致。所以需要合理设置复制积压缓冲区的大小。

## **7、实例高可用——哨兵机制**

哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。

### **7.1监控**

监控——哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。

- 如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；
- 如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。

怎么判断下线？（主观下线和客观下线）

- 主观下线——如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。
- 主观下线的误判——虽然判断为下线了，但是也可能是误判，这种误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。
- 客观下线——为了减少误判，采用哨兵集群的方式（引入多个实例一起判断）。如果多个哨兵都判断这个实例下线，那么这个实例就客观下线（用于判定主库），进行主从切换。

### **7.2选主**

哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。

筛选条件：

- 在线状态，正常连接，且网络状况良好，一般可以通过哨兵PING的超时次数判断，超时次数越小，网络连接状态越好；
- 用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。优先级高的从库得分高。
- 和旧主库同步程度最接近的从库得分高，这个需要看复制积压缓冲区中的两个主库读偏移和从库写偏移的差值，差值越小，同步程度越高。
- 在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。（无解，默认的）

### **7.3通知**

在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。

哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。

### **综上，哨兵需要做两个决策，一次通知：**

- 决策——在监控任务中，哨兵需要判断主库是否处于下线状态；
- 决策——在选主任务中，哨兵也要决定选择哪个从库实例作为主库。
- 通知——将主库信息通知其他从库；通知客户端。

## **8、哨兵集群**

即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作。但是配置时只用到了主库IP和端口，并没有配置其他哨兵信息。

### **8.1基于 pub/sub 机制的哨兵集群组成过程（发布 / 订阅机制）**

（1）相互订阅（redis实例的pub/sub 机制，哨兵订阅redis实例的信息）

哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。这样哨兵就相互知道了各自的信息。

（2）订阅从库信息

这是由哨兵向主库发送 INFO 命令来完成的。哨兵给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。

（3）哨兵与客户端（哨兵的pub/sub 机制，客户端订阅哨兵）

1个哨兵也是1个Redis实例，所以客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。主要的频道有：







客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。

```text
// 订阅 所有实例进入客观下线状态的事件
SUBSCRIBE +odown
```

### **8.2确定主哨兵**

确定主哨兵的过程：

1. 任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-down-by-addr 命令。
2. 其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。
3. 一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。
4. 这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。（Leader 选举）
5. 当前哨兵想成为leader就不能给别的哨兵投Y；投了1个Y，再收到请求只能回复N。任何一个哨兵达到预设的 quorum 值，这个哨兵就是leader。























